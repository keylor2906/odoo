# SOME DESCRIPTIVE TITLE.
# Copyright (C) Odoo S.A.
# This file is distributed under the same license as the odoo package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: odoo 9.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-02-22 23:10-0600\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.0\n"

#: ../../reference/async.rst:6
msgid "Asynchronous Operations"
msgstr ""

#: ../../reference/async.rst:8
msgid ""
"As a language (and runtime), javascript is fundamentally single-threaded."
" This means any blocking request or computation will block the whole page"
" (and, in older browsers, the software itself even preventing users from "
"switching to another tab): a javascript environment can be seen as an "
"event-based runloop where application developers have no control over the"
" runloop itself."
msgstr ""

#: ../../reference/async.rst:15
msgid ""
"As a result, performing long-running synchronous network requests or "
"other types of complex and expensive accesses is frowned upon and "
"asynchronous APIs are used instead."
msgstr ""

#: ../../reference/async.rst:19
msgid ""
"The goal of this guide is to provide some tools to deal with asynchronous"
" systems, and warn against systemic issues or dangers."
msgstr ""

#: ../../reference/async.rst:23
msgid "Deferreds"
msgstr ""

#: ../../reference/async.rst:25
msgid ""
"Deferreds are a form of `promises`_. OpenERP Web currently uses `jQuery's"
" deferred`_."
msgstr ""

#: ../../reference/async.rst:28
msgid ""
"The core idea of deferreds is that potentially asynchronous methods will "
"return a :js:class:`Deferred` object instead of an arbitrary value or "
"(most commonly) nothing."
msgstr ""

#: ../../reference/async.rst:32
msgid ""
"This object can then be used to track the end of the asynchronous "
"operation by adding callbacks onto it, either success callbacks or error "
"callbacks."
msgstr ""

#: ../../reference/async.rst:36
msgid ""
"A great advantage of deferreds over simply passing callback functions "
"directly to asynchronous methods is the ability to :ref:`compose them "
"<reference/async/composition>`."
msgstr ""

#: ../../reference/async.rst:41
msgid "Using deferreds"
msgstr ""

#: ../../reference/async.rst:43
msgid ""
"Deferreds's most important method is :js:func:`Deferred.then`. It is used"
" to attach new callbacks to the deferred object."
msgstr ""

#: ../../reference/async.rst:46
msgid ""
"the first parameter attaches a success callback, called when the deferred"
" object is successfully resolved and provided with the resolved value(s) "
"for the asynchronous operation."
msgstr ""

#: ../../reference/async.rst:50
msgid ""
"the second parameter attaches a failure callback, called when the "
"deferred object is rejected and provided with rejection values (often "
"some sort of error message)."
msgstr ""

#: ../../reference/async.rst:54
msgid ""
"Callbacks attached to deferreds are never \"lost\": if a callback is "
"attached to an already resolved or rejected deferred, the callback will "
"be called (or ignored) immediately. A deferred is also only ever resolved"
" or rejected once, and is either resolved or rejected: a given deferred "
"can not call a single success callback twice, or call both a success and "
"a failure callbacks."
msgstr ""

#: ../../reference/async.rst:61
msgid ""
":js:func:`~Deferred.then` should be the method you'll use most often when"
" interacting with deferred objects (and thus asynchronous APIs)."
msgstr ""

#: ../../reference/async.rst:65
msgid "Building deferreds"
msgstr ""

#: ../../reference/async.rst:67
msgid ""
"After using asynchronous APIs may come the time to build them: for "
"mocks_, to compose deferreds from multiple source in a complex manner, in"
" order to let the current operations repaint the screen or give other "
"events the time to unfold, ..."
msgstr ""

#: ../../reference/async.rst:72
msgid "This is easy using jQuery's deferred objects."
msgstr ""

#: ../../reference/async.rst:74
msgid ""
"this section is an implementation detail of jQuery Deferred objects, the "
"creation of promises is not part of any standard (even tentative) that I "
"know of. If you are using deferred objects which are not jQuery's, their "
"API may (and often will) be completely different."
msgstr ""

#: ../../reference/async.rst:80
msgid ""
"Deferreds are created by invoking their constructor [#]_ without any "
"argument. This creates a :js:class:`Deferred` instance object with the "
"following methods:"
msgstr ""

#: ../../reference/async.rst:84
msgid ":js:func:`Deferred.resolve`"
msgstr ""

#: ../../reference/async.rst:86
msgid ""
"As its name indicates, this method moves the deferred to the \"Resolved\""
" state. It can be provided as many arguments as necessary, these "
"arguments will be provided to any pending success callback."
msgstr ""

#: ../../reference/async.rst:91
msgid ":js:func:`Deferred.reject`"
msgstr ""

#: ../../reference/async.rst:93
msgid ""
"Similar to :js:func:`~Deferred.resolve`, but moves the deferred to the "
"\"Rejected\" state and calls pending failure handlers."
msgstr ""

#: ../../reference/async.rst:96
msgid ":js:func:`Deferred.promise`"
msgstr ""

#: ../../reference/async.rst:98
msgid ""
"Creates a readonly view of the deferred object. It is generally a good "
"idea to return a promise view of the deferred to prevent callers from "
"resolving or rejecting the deferred in your stead."
msgstr ""

#: ../../reference/async.rst:102
msgid ""
":js:func:`~Deferred.reject` and :js:func:`~Deferred.resolve` are used to "
"inform callers that the asynchronous operation has failed (or succeeded)."
" These methods should simply be called when the asynchronous operation "
"has ended, to notify anybody interested in its result(s)."
msgstr ""

#: ../../reference/async.rst:111
msgid "Composing deferreds"
msgstr ""

#: ../../reference/async.rst:113
msgid ""
"What we've seen so far is pretty nice, but mostly doable by passing "
"functions to other functions (well adding functions post-facto would "
"probably be a chore... still, doable)."
msgstr ""

#: ../../reference/async.rst:117
msgid ""
"Deferreds truly shine when code needs to compose asynchronous operations "
"in some way or other, as they can be used as a basis for such "
"composition."
msgstr ""

#: ../../reference/async.rst:121
msgid ""
"There are two main forms of compositions over deferred: multiplexing and "
"piping/cascading."
msgstr ""

#: ../../reference/async.rst:125
msgid "Deferred multiplexing"
msgstr ""

#: ../../reference/async.rst:127
msgid ""
"The most common reason for multiplexing deferred is simply performing "
"multiple asynchronous operations and wanting to wait until all of them "
"are done before moving on (and executing more stuff)."
msgstr ""

#: ../../reference/async.rst:131
msgid "The jQuery multiplexing function for promises is :js:func:`when`."
msgstr ""

#: ../../reference/async.rst:133
msgid ""
"the multiplexing behavior of jQuery's :js:func:`when` is an "
"(incompatible, mostly) extension of the behavior defined in `CommonJS "
"Promises/B`_."
msgstr ""

#: ../../reference/async.rst:137
msgid ""
"This function can take any number of promises [#]_ and will return a "
"promise."
msgstr ""

#: ../../reference/async.rst:140
msgid ""
"The returned promise will be resolved when *all* multiplexed promises are"
" resolved, and will be rejected as soon as one of the multiplexed "
"promises is rejected (it behaves like Python's ``all()``, but with "
"promise objects instead of boolean-ish)."
msgstr ""

#: ../../reference/async.rst:145
msgid ""
"The resolved values of the various promises multiplexed via "
":js:func:`when` are mapped to the arguments of :js:func:`when`'s success "
"callback, if they are needed. The resolved values of a promise are at the"
" same index in the callback's arguments as the promise in the "
":js:func:`when` call so you will have:"
msgstr ""

#: ../../reference/async.rst:160
msgid ""
"in a normal mapping, each parameter to the callback would be an array: "
"each promise is conceptually resolved with an array of 0..n values and "
"these values are passed to :js:func:`when`'s callback. But jQuery treats "
"deferreds resolving a single value specially, and \"unwraps\" that value."
msgstr ""

#: ../../reference/async.rst:166
msgid ""
"For instance, in the code block above if the index of each promise is the"
" number of values it resolves (0 to 3), ``results0`` is an empty array, "
"``results2`` is an array of 2 elements (a pair) but ``results1`` is the "
"actual value resolved by ``p1``, not an array."
msgstr ""

#: ../../reference/async.rst:172
msgid "Deferred chaining"
msgstr ""

#: ../../reference/async.rst:174
msgid ""
"A second useful composition is starting an asynchronous operation as the "
"result of an other asynchronous operation, and wanting the result of "
"both: with the tools described so far, handling e.g. OpenERP's "
"search/read sequence with this would require something along the lines "
"of:"
msgstr ""

#: ../../reference/async.rst:190
msgid ""
"While it doesn't look too bad for trivial code, this quickly gets "
"unwieldy."
msgstr ""

#: ../../reference/async.rst:193
msgid ""
"But :js:func:`~Deferred.then` also allows handling this kind of chains: "
"it returns a new promise object, not the one it was called with, and the "
"return values of the callbacks is important to this behavior: whichever "
"callback is called,"
msgstr ""

#: ../../reference/async.rst:198
msgid ""
"If the callback is not set (not provided or left to null), the resolution"
" or rejection value(s) is simply forwarded to :js:func:`~Deferred.then`'s"
" promise (it's essentially a noop)"
msgstr ""

#: ../../reference/async.rst:202
msgid ""
"If the callback is set and does not return an observable object (a "
"deferred or a promise), the value it returns (``undefined`` if it does "
"not return anything) will replace the value it was given, e.g."
msgstr ""

#: ../../reference/async.rst:212
msgid "will resolve with the sole value ``undefined``."
msgstr ""

#: ../../reference/async.rst:214
msgid ""
"If the callback is set and returns an observable object, that object will"
" be the actual resolution (and result) of the pipe. This means a resolved"
" promise from the failure callback will resolve the pipe, and a failure "
"promise from the success callback will reject the pipe."
msgstr ""

#: ../../reference/async.rst:220
msgid ""
"This provides an easy way to chain operation successes, and the previous "
"piece of code can now be rewritten:"
msgstr ""

#: ../../reference/async.rst:229
msgid ""
"the result of the whole expression will encode failure if either "
"``search`` or ``read`` fails (with the right rejection values), and will "
"be resolved with ``read``'s resolution values if the chain executes "
"correctly."
msgstr ""

#: ../../reference/async.rst:234
msgid ""
":js:func:`~Deferred.then` is also useful to adapt third-party promise-"
"based APIs, in order to filter their resolution value counts for instance"
" (to take advantage of :js:func:`when` 's special treatment of single-"
"value promises)."
msgstr ""

#: ../../reference/async.rst:240
msgid "jQuery.Deferred API"
msgstr ""

#: ../../reference/async.rst:244
msgid "deferred objects to multiplex"
msgstr ""

#: ../../reference/async.rst:245
msgid "a multiplexed deferred"
msgstr ""

#: ../../reference/async.rst:246 ../../reference/async.rst:268
#: ../../reference/async.rst:285 ../../reference/async.rst:300
msgid ":js:class:`Deferred`"
msgstr ""

#: ../../reference/async.rst:252
msgid ""
"Attaches new callbacks to the resolution or rejection of the deferred "
"object. Callbacks are executed in the order they are attached to the "
"deferred."
msgstr ""

#: ../../reference/async.rst:256
msgid ""
"To provide only a failure callback, pass ``null`` as the "
"``doneCallback``, to provide only a success callback the second argument "
"can just be ignored (and not passed at all)."
msgstr ""

#: ../../reference/async.rst:260
msgid ""
"Returns a new deferred which resolves to the result of the corresponding "
"callback, if a callback returns a deferred itself that new deferred will "
"be used as the resolution of the chain."
msgstr ""

#: ../../reference/async.rst:265 ../../reference/async.rst:282
msgid "function called when the deferred is resolved"
msgstr ""

#: ../../reference/async.rst:266 ../../reference/async.rst:297
msgid "function called when the deferred is rejected"
msgstr ""

#: ../../reference/async.rst:267 ../../reference/async.rst:284
#: ../../reference/async.rst:299
msgid "the deferred object on which it was called"
msgstr ""

#: ../../reference/async.rst:272
msgid ""
"Attaches a new success callback to the deferred, shortcut for "
"``deferred.then(doneCallback)``."
msgstr ""

#: ../../reference/async.rst:275
msgid ""
"a difference is the result of :js:func:`Deferred.done`'s is ignored "
"rather than forwarded through the chain"
msgstr ""

#: ../../reference/async.rst:278
msgid ""
"This is a jQuery extension to `CommonJS Promises/A`_ providing little "
"value over calling :js:func:`~Deferred.then` directly, it should be "
"avoided."
msgstr ""

#: ../../reference/async.rst:289
msgid ""
"Attaches a new failure callback to the deferred, shortcut for "
"``deferred.then(null, failCallback)``."
msgstr ""

#: ../../reference/async.rst:292
msgid ""
"A second jQuery extension to `Promises/A <CommonJS Promises/A>`_. "
"Although it provides more value than :js:func:`~Deferred.done`, it still "
"is not much and should be avoided as well."
msgstr ""

#: ../../reference/async.rst:304
msgid ""
"Returns a read-only view of the deferred object, with all mutators "
"(resolve and reject) methods removed."
msgstr ""

#: ../../reference/async.rst:309
msgid ""
"Called to resolve a deferred, any value provided will be passed onto the "
"success handlers of the deferred object."
msgstr ""

#: ../../reference/async.rst:312
msgid ""
"Resolving a deferred which has already been resolved or rejected has no "
"effect."
msgstr ""

#: ../../reference/async.rst:317
msgid ""
"Called to reject (fail) a deferred, any value provided will be passed "
"onto the failure handler of the deferred object."
msgstr ""

#: ../../reference/async.rst:320
msgid ""
"Rejecting a deferred which has already been resolved or rejected has no "
"effect."
msgstr ""

#: ../../reference/async.rst:323
msgid ""
"or simply calling :js:class:`Deferred` as a function, the result is the "
"same"
msgstr ""

#: ../../reference/async.rst:326
msgid ""
"or not-promises, the `CommonJS Promises/B`_ role of :js:func:`when` is to"
" be able to treat values and promises uniformly: :js:func:`when` will "
"pass promises through directly, but non-promise values and objects will "
"be transformed into a resolved promise (resolving themselves with the "
"value itself)."
msgstr ""

#: ../../reference/async.rst:332
msgid ""
"jQuery's :js:func:`when` keeps this behavior making deferreds easy to "
"build from \"static\" values, or allowing defensive code where expected "
"promises are wrapped in :js:func:`when` just in case."
msgstr ""

